{"version":3,"sources":["Tree.js"],"names":["define","$","treetable","Node","Tree","table","settings","this","tree","nodes","roots","prototype","collapseAll","node","_i","_len","_ref","_results","length","push","collapse","expandAll","expand","findLastNode","children","loadRows","rows","row","i","data","nodeIdAttr","id","parentId","addChild","updateBranchLeafClass","move","destination","nodeParent","parentNode","inArray","ancestors","setParent","_moveRows","render","removeNode","unloadBranch","remove","removeChild","splice","show","sortBranch","sortFun","sort","_sortChildRows","slice","insertAfter"],"mappings":"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","file":"../Tree.js","sourcesContent":["define([\r\n\t\"skylark-jquery\",\r\n\t\"./treetable\",\r\n\t\"./Node\"\r\n],function($,treetable,Node){\r\n\r\n    function Tree(table, settings) {\r\n      this.table = table;\r\n      this.settings = settings;\r\n      this.tree = {};\r\n\r\n      // Cache the nodes and roots in simple arrays for quick access/iteration\r\n      this.nodes = [];\r\n      this.roots = [];\r\n    }\r\n\r\n    Tree.prototype.collapseAll = function() {\r\n      var node, _i, _len, _ref, _results;\r\n      _ref = this.nodes;\r\n      _results = [];\r\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\r\n        node = _ref[_i];\r\n        _results.push(node.collapse());\r\n      }\r\n      return _results;\r\n    };\r\n\r\n    Tree.prototype.expandAll = function() {\r\n      var node, _i, _len, _ref, _results;\r\n      _ref = this.nodes;\r\n      _results = [];\r\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\r\n        node = _ref[_i];\r\n        _results.push(node.expand());\r\n      }\r\n      return _results;\r\n    };\r\n\r\n    Tree.prototype.findLastNode = function (node) {\r\n      if (node.children.length > 0) {\r\n        return this.findLastNode(node.children[node.children.length - 1]);\r\n      } else {\r\n        return node;\r\n      }\r\n    };\r\n\r\n    Tree.prototype.loadRows = function(rows) {\r\n      var node, row, i;\r\n\r\n      if (rows != null) {\r\n        for (i = 0; i < rows.length; i++) {\r\n          row = $(rows[i]);\r\n\r\n          if (row.data(this.settings.nodeIdAttr) != null) {\r\n            node = new Node(row, this.tree, this.settings);\r\n            this.nodes.push(node);\r\n            this.tree[node.id] = node;\r\n\r\n            if (node.parentId != null && this.tree[node.parentId]) {\r\n              this.tree[node.parentId].addChild(node);\r\n            } else {\r\n              this.roots.push(node);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        node = this.nodes[i].updateBranchLeafClass();\r\n      }\r\n\r\n      return this;\r\n    };\r\n\r\n    Tree.prototype.move = function(node, destination) {\r\n      // Conditions:\r\n      // 1: +node+ should not be inserted as a child of +node+ itself.\r\n      // 2: +destination+ should not be the same as +node+'s current parent (this\r\n      //    prevents +node+ from being moved to the same location where it already\r\n      //    is).\r\n      // 3: +node+ should not be inserted in a location in a branch if this would\r\n      //    result in +node+ being an ancestor of itself.\r\n      var nodeParent = node.parentNode();\r\n      if (node !== destination && destination.id !== node.parentId && $.inArray(node, destination.ancestors()) === -1) {\r\n        node.setParent(destination);\r\n        this._moveRows(node, destination);\r\n\r\n        // Re-render parentNode if this is its first child node, and therefore\r\n        // doesn't have the expander yet.\r\n        if (node.parentNode().children.length === 1) {\r\n          node.parentNode().render();\r\n        }\r\n      }\r\n\r\n      if(nodeParent){\r\n        nodeParent.updateBranchLeafClass();\r\n      }\r\n      if(node.parentNode()){\r\n        node.parentNode().updateBranchLeafClass();\r\n      }\r\n      node.updateBranchLeafClass();\r\n      return this;\r\n    };\r\n\r\n    Tree.prototype.removeNode = function(node) {\r\n      // Recursively remove all descendants of +node+\r\n      this.unloadBranch(node);\r\n\r\n      // Remove node from DOM (<tr>)\r\n      node.row.remove();\r\n\r\n      // Remove node from parent children list\r\n      if (node.parentId != null) {\r\n        node.parentNode().removeChild(node);\r\n      }\r\n\r\n      // Clean up Tree object (so Node objects are GC-ed)\r\n      delete this.tree[node.id];\r\n      this.nodes.splice($.inArray(node, this.nodes), 1);\r\n\r\n      return this;\r\n    }\r\n\r\n    Tree.prototype.render = function() {\r\n      var root, _i, _len, _ref;\r\n      _ref = this.roots;\r\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\r\n        root = _ref[_i];\r\n\r\n        // Naming is confusing (show/render). I do not call render on node from\r\n        // here.\r\n        root.show();\r\n      }\r\n      return this;\r\n    };\r\n\r\n    Tree.prototype.sortBranch = function(node, sortFun) {\r\n      // First sort internal array of children\r\n      node.children.sort(sortFun);\r\n\r\n      // Next render rows in correct order on page\r\n      this._sortChildRows(node);\r\n\r\n      return this;\r\n    };\r\n\r\n    Tree.prototype.unloadBranch = function(node) {\r\n      // Use a copy of the children array to not have other functions interfere\r\n      // with this function if they manipulate the children array\r\n      // (eg removeNode).\r\n      var children = node.children.slice(0),\r\n          i;\r\n\r\n      for (i = 0; i < children.length; i++) {\r\n        this.removeNode(children[i]);\r\n      }\r\n\r\n      // Reset node's collection of children\r\n      node.children = [];\r\n\r\n      node.updateBranchLeafClass();\r\n\r\n      return this;\r\n    };\r\n\r\n    Tree.prototype._moveRows = function(node, destination) {\r\n      var children = node.children, i;\r\n\r\n      node.row.insertAfter(destination.row);\r\n      node.render();\r\n\r\n      // Loop backwards through children to have them end up on UI in correct\r\n      // order (see #112)\r\n      for (i = children.length - 1; i >= 0; i--) {\r\n        this._moveRows(children[i], node);\r\n      }\r\n    };\r\n\r\n    // Special _moveRows case, move children to itself to force sorting\r\n    Tree.prototype._sortChildRows = function(parentNode) {\r\n      return this._moveRows(parentNode, parentNode);\r\n    };\r\n\r\n    return treetable.Tree = Tree;\t\r\n})"]}